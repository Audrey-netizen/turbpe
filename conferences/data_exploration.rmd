---
output:
  html_document: default
  pdf_document: default
---
Working directory info: IMPORTANT NOTE, keep this directory listing identical
to minimize wd errors between devices working on the same repository
  Yes that means please create a folder called "repos"
```{r}
setwd("~/Documents/repos/turbpe")
```

Packages list, plus Audrey's versions of each package
  I didn't make it mandatory to download a specific version of each package as I
  don't want anyone to make redundant downloads, just commented what I'm using
  FYI Andrew we should pretty much always be using the same versions of packages
  since we're both on macbook M4 silicone chips, so this should never be
  something to worry about for you
```{r}
library(corrplot) #V1.1.6
library(dplyr) #V1.1.4
library(ggplot2) #V4.0.0
library(lavaan) #V0.6-20
library(piecewiseSEM) #V2.3.1
library(readr) #V2.1.5
#apparently this is faster than read.csv? Will try it, hopefully nothing breaks
library(scales) #V1.4.0
library(semPlot) #1.1.7
library(tidyverse) #V2.0.0
library(vegan) #V2.7-1

```

##Part 1: Data exploration

Loading up the csv files + assigning them variables
```{r}
abiotics <- read_csv("~/Documents/repos/turbpe/spreadsheets/abiotics.csv")
flowers <- read_csv("~/Documents/repos/turbpe/spreadsheets/flowers.csv")
plant_IDs <- read_csv("~/Documents/repos/turbpe/spreadsheets/Plant_ID_list.csv")
soil_data <- read_csv("~/Documents/repos/turbpe/spreadsheets/soil.csv")
road_widths <- read_csv("~/Documents/repos/turbpe/spreadsheets/road_widths.csv")

#for bee captures we need to further filter it to only include the 8 replicates
#being used for conference presentations (thanks Andrew :3)
bee_captures_8th <- read_csv("~/Documents/repos/turbpe/spreadsheets/bee_captures.csv") %>%
  filter(Replicate >= 1 & Replicate <= 8)
```

Just for my own viewing purposes here, makes rest easier
```{r}
names(bee_captures_8th)
names(abiotics)
names(flowers)
names(plant_IDs)
names(road_widths)
```

What the heck is a glipmse
```{r}
glimpse(abiotics)
glimpse(flowers)
glimpse(plant_IDs)
glimpse(road_widths)
# No really, I tried using this function now, it's giving nothing. I would
# rather just directly look at the csv files...
```

Basic summaries of bees we caught, starting with family
```{r}
family_summary <- bee_captures_8th %>%
  count(Family, name = "Count") %>%
  arrange(desc(Count))

print(family_summary)

genus_summary <- bee_captures_8th %>%
  count(Genus, name = "Count") %>%
  arrange(desc(Count))

print(genus_summary)

# No surprises, this upcoming one is gonna be very skewed to a certain species,
# since we know exactly what species it is as soon as we see an Apis... and we
# see a lot of Apis. Functionally useless bit of code rn but it's fun
species_summary <- bee_captures_8th %>%
  count(Species, name = "Count") %>%
  arrange(desc(Count))

print(species_summary)
```

Figure for this summary, will stick with just genus for now
```{r}

# This bit is redundant but I think it helps with clarity!
genus_summary <- bee_captures_8th %>%
  count(Genus, name = "Count") %>%
  arrange(desc(Count))

# Bar plot
# theme_minimal wow so cool, why doesn't everyone use this?
    # UI designers ranting about people being upset at them simplifying
    # in a nutshell hehe
ggplot(genus_summary, aes(x = reorder(Genus, -Count), y = Count, fill = Genus)) +
  geom_bar(stat = "identity") +
  scale_fill_viridis_d() +  # Colourblind-friendly <3
  labs(
    title = "Bee Genera Captured",
    x = "Genus",
    y = "Number of Captures"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    legend.position = "none",  # Legend would be bloat
    plot.margin = margin(1, 1, 1, 1.5, "cm"),  # Slight margins change
    panel.grid.major.x = element_blank()  # No grids plz
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)))
```

Repeat this but across four months
```{r}
# This is the important part, actually sorts out the month categories I desire
# for visibility purposes
months <- c("05", "06", "07", "08")
month_names <- c("May", "June", "July", "August")

# Ok this is an important part too... this for loop simultaneously is what sorts
# through the above months sections made and also makes it so all four figures
# are output in quick succession without copy pasting this four times :)
for (i in 1:length(months)) {
  month_data <- bee_captures_8th %>%
    filter(str_detect(Date, paste0("-", months[i], "-"))) %>%
    count(Genus, name = "Count") %>%
    arrange(desc(Count))
  
  p <- ggplot(month_data, aes(x = reorder(Genus, -Count), y = Count, fill = Genus)) +
    geom_bar(stat = "identity") +
    scale_fill_viridis_d() +
    labs(
      title = paste("Bee Genera Captured -", month_names[i]),
      x = "Genus",
      y = "Number of Captures"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
      axis.text.y = element_text(size = 10),
      axis.title = element_text(size = 12, face = "bold"),
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
      legend.position = "none",
      plot.margin = margin(1, 1, 1, 1.5, "cm"),
      panel.grid.major.x = element_blank()
    ) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.1)))
  
  print(p)
}
# Now that we're using a for loop we actually are assigning this production of
# the plot a variable
```

I wonder if converting to log scales will give anything of value, likely not
worth it with the monthly ones as the data is limited... eh it's probably worth
it but I can't be bothered for now
```{r}
genus_summary <- bee_captures_8th %>%
  count(Genus, name = "Count") %>%
  arrange(desc(Count))

# Honestly I'm still trying to figure out why these two lines of code are here,
# for now they serve the purpose of assigning a variable we proceed to use and
# setting up our log10 with count of +1 scale/format, but ehhhh I feel like this
# can be written more efficiently, I'm just not good enough for it atm
genus_summary_log <- genus_summary %>%
  mutate(LogCount = log10(Count + 1))

# Make the plot
ggplot(genus_summary_log, aes(x = reorder(Genus, -Count), y = LogCount, fill = Genus)) +
  geom_bar(stat = "identity") +
  scale_fill_viridis_d() +  # Colourblind-friendly <3
  labs(
    title = "Bee Genera Captured (Log Scale)",
    x = "Genus",
    y = "Log10(Count + 1)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    legend.position = "none",  # Legend would be bloat
    plot.margin = margin(1, 1, 1, 1.5, "cm"),  # Slight margins change
    panel.grid.major.x = element_blank()  # No grids plz
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)))
```

Baseline for organizing plant data
```{r}

flowers <- read_csv("~/Documents/repos/turbpe/spreadsheets/flowers.csv")
plant_IDs <- read_csv("~/Documents/repos/turbpe/spreadsheets/Plant_ID_list.csv")
# I believe this is functionally useless, so may be removed later, but for now I
# think it helps remind readers which datasets we are working with coming up
```

```{r}
# Removing potential duplicates...this is such a flop. I shouldn't have any as
# of now in this RMD document but this is probably a good thing to do when
# you're chucking a bunch of lines of code for making figures?
plant_IDs <- plant_IDs[!duplicated(plant_IDs$ID), ]

# Create a proper taxonomic name column in plant_id_list
plant_IDs$Taxonomic_Name <- ifelse(
  !is.na(plant_IDs$Genus) & plant_IDs$Genus != "" & 
  !is.na(plant_IDs$Species) & plant_IDs$Species != "",
  paste(plant_IDs$Genus, plant_IDs$Species),
  as.character(plant_IDs$ID)  # Keep ID as character if no taxonomic name
)
```

```{r}
# Remove any duplicate rows from plant_id_list to avoid merge issues
plant_IDs <- plant_IDs[!duplicated(plant_IDs$ID), ]

# Create a proper taxonomic name column in plant_IDs
plant_IDs$Taxonomic_Name <- ifelse(
  !is.na(plant_IDs$Genus) & plant_IDs$Genus != "" & 
  !is.na(plant_IDs$Species) & plant_IDs$Species != "",
  paste(plant_IDs$Genus, plant_IDs$Species),
  as.character(plant_IDs$ID)  # Keep ID as character if no taxonomic name
)
```

```{r}
# Merging flowers data with taxonomic names
flowers_with_taxonomy <- merge(
  flowers,
  plant_IDs[, c("ID", "Taxonomic_Name")],
  by.x = "Species ID",  
  by.y = "ID",
  all.x = TRUE
)

# For Species IDs that didn't match, keeping original ID
flowers_with_taxonomy$Taxonomic_Name <- ifelse(
  is.na(flowers_with_taxonomy$Taxonomic_Name),
  as.character(flowers_with_taxonomy$`Species ID`),
  flowers_with_taxonomy$Taxonomic_Name
)
```

Most frequent flowering plants observed across all sites... to a certain amount
anyways, we still need this thing to be yknow eyeball friendly
```{r}
# Oh boy time to call/create a variable again
# this is important to set up the actual quantities that we observe each unique
# species for the following bits of code
observation_counts <- flowers_with_taxonomy %>%
  count(Taxonomic_Name, name = "Observation_Count") %>%
  arrange(desc(Observation_Count))

# Go to top 20 because top 100 is kinda hard to read/look at
top_species <- observation_counts %>%
  top_n(20, Observation_Count) %>%
  arrange(desc(Observation_Count))

# Making the plot, same colourblind-friendly style as last time
ggplot(top_species, aes(x = reorder(Taxonomic_Name, Observation_Count), 
                        y = Observation_Count, 
                        fill = Taxonomic_Name)) +
  geom_bar(stat = "identity") +
  scale_fill_viridis_d() +  # Colourblind-friendly <3
  coord_flip() +
  labs(
    title = "Top 20 Most Frequently Observed Plant Species
    (All Sites)",
    x = "Plant Species", 
    y = "Number of Observations"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10),
    axis.title = element_text(size = 12, face = "bold"),
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    legend.position = "none",  # Legend would be bloat
    plot.margin = margin(1, 1, 1, 1.5, "cm"),
    panel.grid.major.y = element_blank()  # No horizontal grids plz
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1)))
```

Do the same but sorted for treatment, positive and negative control
```{r}
# Making different categories from the second letter of the "Site" column
flowers_with_taxonomy <- flowers_with_taxonomy %>%
  mutate(Treatment_Type = case_when(
    grepl("^.[Tt]", Site) ~ "Treatment",
    grepl("^.[Nn]", Site) ~ "Negative Control", 
    grepl("^.[Pp]", Site) ~ "Positive Control",
    TRUE ~ "Other"
  ))

# Calling observation variables again to cause less repetitive code
observation_counts_by_treatment <- flowers_with_taxonomy %>%
  count(Treatment_Type, Taxonomic_Name, name = "Observation_Count") %>%
  arrange(Treatment_Type, desc(Observation_Count))

# Top 20 species for each treatment type
top_species_by_treatment <- observation_counts_by_treatment %>%
  group_by(Treatment_Type) %>%
  top_n(20, Observation_Count) %>%
  arrange(Treatment_Type, desc(Observation_Count)) %>%
  ungroup()

# Create a function to make the plot for each treatment type
create_treatment_plot <- function(treatment_data, treatment_name) {
  ggplot(treatment_data, aes(x = reorder(Taxonomic_Name, Observation_Count), 
                            y = Observation_Count, 
                            fill = Taxonomic_Name)) +
    geom_bar(stat = "identity") +
    scale_fill_viridis_d() +
    coord_flip() +
    labs(
      title = paste("Top 20 Species -", treatment_name),
      x = "Plant Species", 
      y = "Number of Observations"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(size = 10),
      axis.text.y = element_text(size = 10),
      axis.title = element_text(size = 12, face = "bold"),
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
      legend.position = "none",
      plot.margin = margin(1, 1, 1, 1.5, "cm"),
      panel.grid.major.y = element_blank()
    ) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.1)))
}

# Plots for each treatment type
treatment_plots <- list()

treatment_plots$treatment <- create_treatment_plot(
  top_species_by_treatment %>% filter(Treatment_Type == "Treatment"),
  "Treatment"
)

treatment_plots$negative <- create_treatment_plot(
  top_species_by_treatment %>% filter(Treatment_Type == "Negative Control"),
  "Negative Control"
)

treatment_plots$positive <- create_treatment_plot(
  top_species_by_treatment %>% filter(Treatment_Type == "Positive Control"),
  "Positive Control"
)

treatment_plots$treatment
treatment_plots$negative  
treatment_plots$positive
```

I think there is a good reason to log transform some data here, the treatment
and positive control seem to have more similar distributions of plant species
```{r}
# log10 version of the plotting function
create_treatment_plot_log <- function(treatment_data, treatment_name) {
  ggplot(treatment_data, aes(x = reorder(Taxonomic_Name, Observation_Count), 
                            y = Observation_Count + 1,
                            fill = Taxonomic_Name)) +
    geom_bar(stat = "identity") +
    scale_fill_viridis_d() +
    scale_y_log10() +  
    coord_flip() +
    labs(
      title = paste("Top 20 Species -", treatment_name, "(Log10 Scale)"),
      x = "Plant Species", 
      y = "Number of Observations + 1 (Log10)"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(size = 10),
      axis.text.y = element_text(size = 10),
      axis.title = element_text(size = 12, face = "bold"),
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
      legend.position = "none",
      plot.margin = margin(1, 1, 1, 1.5, "cm"),
      panel.grid.major.y = element_blank()
    )
}

# log10 plots for Treatment and Positive Control
log_treatment_plot <- create_treatment_plot_log(
  top_species_by_treatment %>% filter(Treatment_Type == "Treatment"),
  "Treatment"
)

log_positive_plot <- create_treatment_plot_log(
  top_species_by_treatment %>% filter(Treatment_Type == "Positive Control"),
  "Positive Control"
)

log_treatment_plot
log_positive_plot
```

Trying to get something out of these log distributions... I was taught
permanova across like 3 different ecology classes and in Eryn's biostats course
so it must be useful for something, right?
```{r}
#I'm going to be honest I still kinda have no idea how this matrix stuff works
# TwT, or maybe I do conceptually but whenever I try to think about it more it
# gets blurry
comm_matrix_sites <- flowers_with_taxonomy %>%
  filter(Treatment_Type %in% c("Treatment", "Positive Control")) %>%
  count(Site, Taxonomic_Name, name = "Count") %>%
  pivot_wider(names_from = Taxonomic_Name, values_from = Count, values_fill = 0) %>%
  column_to_rownames("Site") %>%
  as.matrix()

# Make treatment groups variable to use for actually doing the permanova 
treatment_groups <- flowers_with_taxonomy %>%
  filter(Treatment_Type %in% c("Treatment", "Positive Control")) %>%
  distinct(Site, Treatment_Type) %>%
  arrange(Site) %>%
  pull(Treatment_Type)

# The thing
permanova_result <- adonis2(comm_matrix_sites ~ treatment_groups, 
                           method = "bray",
                           permutations = 999)  # Increase permutations for better p-value

print(permanova_result)
```

Permanova for treatment vs negative just to really rub it in (or uh, be
scientifically principled, whatever that means)
```{r}

# Have to add this bit in before basically just copy paste since I am bringing
# in the negative control data in a new context
site_counts_neg_treat <- flowers_with_taxonomy %>%
  filter(Treatment_Type %in% c("Treatment", "Negative Control")) %>%
  distinct(Site, Treatment_Type) %>%
  count(Treatment_Type)

print(site_counts_neg_treat)

comm_matrix_neg_treat <- flowers_with_taxonomy %>%
  filter(Treatment_Type %in% c("Treatment", "Negative Control")) %>%
  count(Site, Taxonomic_Name, name = "Count") %>%
  pivot_wider(names_from = Taxonomic_Name, values_from = Count, values_fill = 0) %>%
  column_to_rownames("Site") %>%
  as.matrix()

treatment_groups_neg_treat <- flowers_with_taxonomy %>%
  filter(Treatment_Type %in% c("Treatment", "Negative Control")) %>%
  distinct(Site, Treatment_Type) %>%
  arrange(Site) %>%
  pull(Treatment_Type)

permanova_neg_treat <- adonis2(comm_matrix_neg_treat ~ treatment_groups_neg_treat, 
                              method = "bray",
                              permutations = 999)

print(permanova_neg_treat)
```


##Part 2, building towards SEM

Okay this starts to get pretty scary I won't lie
Background context, I was basically trying to set up structural equation model/
SEM stuff, and decided to just chuck everything in there as far as my data at
this current point in time goes. But I did have a hunch that the road width data
would be pointless or maybe even detrimental here. Under the current context of
data available, everything works on a "mean or total amount obtained in each
given day/half hour sampling interval", so having a constant static number for
each road seemed not ideal.

Regardless, I did end up choosing to do this analysis anyways, so let's do a
walk-through!

Okay firstly, that bee_summary from earlier is getting converted to a format
which is hopefully more digestable for our various statistical models and SEM
```{r}
bee_summary <- bee_captures_8th %>%
  group_by(Site, Replicate) %>%
  summarise(
    bee_abundance = n(),
    bee_richness = n_distinct(Genus, Species, na.rm = TRUE),
    .groups = 'drop'
  )
# This summarise function (ewww American spelling) seems to be quite useful for
# such a scenario
```

Effectively the same task for flowers rather than bees  
```{r}
flower_summary <- flowers_with_taxonomy %>%
  filter(Replicate >= 1 & Replicate <= 8) %>%
  group_by(Site, Replicate) %>%
  summarise(
    total_flowers = sum(`# of Flowering Units`, na.rm = TRUE),
    flower_richness = n_distinct(Taxonomic_Name),
    .groups = 'drop'
  )
```

Now this is getting rid of the excess traffic data I have in the CSV in the
slots for mean and total data etc
```{r}
# Why is a function called cat so dang useful in not very cat-like circumstances
# well I guess maybe a cat will like try and. open their treats container or
# whatever to look ahead?
# Now process with better handling of traffic data
abiotic_summary <- abiotics %>%
  # Clean site names
  mutate(Site_Clean = case_when(
    grepl("Mean", Site) ~ gsub(" Mean", "", Site),
    grepl("M/S", Site) ~ gsub(" M/S", "", Site),
    TRUE ~ gsub("\\s.*", "", Site)
  )) %>%
  # Filter out "Total" and summary rows
  filter(!grepl("Total|Mean|M/S", Site, ignore.case = TRUE)) %>%
  # Convert traffic columns from character to numeric, handling special cases
  mutate(
    Traffic_passenger = case_when(
      Traffic_passenger %in% c("", "NA", "?", "N/A") ~ "0",
      TRUE ~ Traffic_passenger
    ),
    Traffic_Bike = case_when(
      Traffic_Bike %in% c("", "NA", "?", "N/A") ~ "0",
      TRUE ~ Traffic_Bike
    ),
    Traffic_truck = case_when(
      Traffic_truck %in% c("", "NA", "?", "N/A") ~ "0",
      TRUE ~ Traffic_truck
    ),
    # Now convert to numeric
    Traffic_passenger = as.numeric(Traffic_passenger),
    Traffic_Bike = as.numeric(Traffic_Bike),
    Traffic_truck = as.numeric(Traffic_truck)
  ) %>%
  # Group by clean site and date
  group_by(Site_Clean, Date) %>%
  summarise(
    mean_temp = mean(Temp, na.rm = TRUE),
    mean_humidity = mean(Humidity, na.rm = TRUE),
    mean_wind = mean(Wind, na.rm = TRUE),
    mean_volume = mean(Volume, na.rm = TRUE),
    total_traffic_passenger = sum(Traffic_passenger, na.rm = TRUE),
    total_traffic_bike = sum(Traffic_Bike, na.rm = TRUE),
    total_traffic_truck = sum(Traffic_truck, na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  # Create replicate numbers based on date order
  group_by(Site_Clean) %>%
  arrange(Date) %>%
  mutate(Replicate = as.integer(factor(Date))) %>%
  ungroup() %>%
  # Filter to replicates 1-8
  filter(Replicate >= 1 & Replicate <= 8) %>%
  select(-Date) %>%
  rename(Site = Site_Clean)
# This summary function (ewww American spelling) seems to be quite useful for
# such a scenario
```

Here's the part that's to do with the road width
```{r}
# Why is a function called cat so dang useful in not very cat-like circumstances
# well I guess maybe a cat will like try and. open their treats container or
# whatever to look ahead?
cat("Column names in road_widths:\n")
print(colnames(road_widths))

cat("\nFirst few rows of road_widths:\n")
print(head(road_widths))

# This helped out with uh... uh... idk I was having a hard time making things
# work without it
road_width_col <- grep("road|width|Road|Width", colnames(road_widths), value = TRUE, ignore.case = TRUE)
cat("\nRoad width related columns:\n")
print(road_width_col)

road_data <- road_widths %>%
  mutate(Site = trimws(Site)) %>%
  select(Site, all_of(road_width_col)) %>%
  rename(road_width = 2)  # Rename the second column to a standard name

# Actually forming the three different types in this context
create_site_type <- function(site_code) {
  site_code <- as.character(site_code)
  if (grepl("P", site_code)) return("Positive")
  if (grepl("N", site_code)) return("Negative") 
  if (grepl("T", site_code)) return("Treatment")
  return(NA_character_)
}
```

Diversity indexes that are not just helpful on their own but a variable relevant
to measure to
```{r}
# For da bees
bee_diversity_indices <- bee_captures_8th %>%
  group_by(Site, Replicate, Genus, Species) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(Site, Replicate) %>%
  summarise(
    bee_shannon = ifelse(n() > 1, diversity(count, index = "shannon"), 0),
    .groups = 'drop'
  )

# For da flowers, wow that... kinda looks similar to the last one, how strange
flower_diversity_indices <- flowers_with_taxonomy %>%
  filter(Replicate >= 1 & Replicate <= 8) %>%
  group_by(Site, Replicate, Taxonomic_Name) %>%
  summarise(count = sum(`# of Flowering Units`, na.rm = TRUE), .groups = 'drop') %>%
  group_by(Site, Replicate) %>%
  summarise(
    flower_shannon = ifelse(n() > 1, diversity(count, index = "shannon"), 0),
    .groups = 'drop'
  )
```

Make all the bits join together then produce a csv file... which I have since
commented out so I don't get a bunch of duplicate files when test running this
and so that knitting actually works
```{r}
sem_data <- bee_summary %>%
  full_join(flower_summary, by = c("Site", "Replicate")) %>%
  left_join(abiotic_summary, by = c("Site", "Replicate")) %>%
  left_join(road_data, by = "Site") %>%
  left_join(bee_diversity_indices, by = c("Site", "Replicate")) %>%
  left_join(flower_diversity_indices, by = c("Site", "Replicate")) %>%
  mutate(
    Site_Type = sapply(Site, create_site_type),
    # I have to manually get rid of N/As? I thought excel made them zero by
    #default TwT
    across(c(bee_abundance, bee_richness, total_flowers, flower_richness), 
           ~replace_na(., 0)),
    # Create total traffic variable
    total_traffic = total_traffic_passenger + total_traffic_bike + total_traffic_truck,
    # Handle NA values in diversity indices
    bee_shannon = replace_na(bee_shannon, 0),
    flower_shannon = replace_na(flower_shannon, 0)
  )
```

Morale booster yippeeee
```{r}
cat("\nSummary statistics:\n")
summary(sem_data %>% select(-Site, -Site_Type))

# The below is a good use for the one time
#write_csv(sem_data, "sem_prepared_data.csv")

cat("\nData preparation complete! File saved as 'sem_prepared_data.csv'\n")
```


Load up the piece of data we just made
```{r}
sem_prepared_data <- read_csv("~/Documents/repos/turbpe/spreadsheets/sem_prepared_data.csv")

# Look at the data
cat("Loaded sem_prepared_data structure:\n")
print(str(sem_prepared_data))

# Clean data
sem_data_clean <- sem_prepared_data %>%
  filter(!is.na(mean_temp) & 
         !is.na(mean_humidity) & 
         !is.na(road_width) &
         !is.na(total_traffic))

cat("\nClean dataset dimensions:", dim(sem_data_clean), "\n")

# Standardize variables
sem_data_std <- sem_data_clean %>%
  mutate(across(where(is.numeric), scale))

# SEM model
simple_sem_model <- '
  bee_abundance ~ total_flowers + total_traffic + road_width
  bee_richness ~ flower_richness + total_traffic
  total_flowers ~ total_traffic + road_width + mean_temp
  flower_richness ~ total_traffic + road_width + mean_temp
  bee_abundance ~~ bee_richness
  total_flowers ~~ flower_richness
  total_traffic ~~ road_width + mean_temp
  road_width ~~ mean_temp
'

# Fit model
simple_fit <- sem(simple_sem_model, data = sem_data_std)

# Results
cat("\nSEM MODEL SUMMARY:\n")
print(summary(simple_fit, standardized = TRUE, fit.measures = TRUE, rsq = TRUE))

# Significant paths
cat("\nSIGNIFICANT PATHS (p < 0.05):\n")
param_table <- parameterEstimates(simple_fit, standardized = TRUE) %>%
  filter(op == "~" & pvalue < 0.05) %>%
  select(From = rhs, To = lhs, Estimate = est, Std_Coefficient = std.all, P_Value = pvalue)

print(param_table)

# Site comparison
cat("\nSITE TYPE COMPARISON:\n")
site_comparison <- sem_data_clean %>%
  group_by(Site_Type) %>%
  summarise(
    n = n(),
    mean_bees = mean(bee_abundance),
    mean_flowers = mean(total_flowers),
    mean_traffic = mean(total_traffic)
  )

print(site_comparison)

# Save results
#write_csv(param_table, "sem_path_coefficients.csv")
#write_csv(site_comparison, "site_type_comparison.csv")

cat("\nDing dong make the figure now\n")
```

Words summary, hope it helps!
```{r}
key_findings <- data.frame(
  Relationship = c(
    "Flower Diversity → Bee Diversity",
    "Flower Abundance → Bee Abundance", 
    "Traffic → Flower Diversity",
    "Traffic → Bee Abundance",
    "Environmental Factors → Direct Effects"
  ),
  Effect = c("Strong Positive", "Moderate Positive", "Negative", "Negative", "Minimal"),
  Strength = c("***", "***", "*", "*", "NS"),
  Interpretation = c(
    "Diverse flowers support diverse bee communities",
    "More flowers support more individual bees",
    "Traffic reduces plant species diversity",
    "Traffic may directly reduce bee numbers",
    "Temperature, humidity, road width show weak direct effects"
  )
)

print(key_findings)
```

Here is the actual SEM plot... which I'm surprised even turned out half-okay to
be honest considering my track record with this package
```{r}
if(require(semPlot)) {
  
  semPaths(simple_fit,
          what = "std",
          whatLabels = "std",
          style = "lisrel",
          layout = "tree",
          sizeMan = 10,
          edge.label.cex = 0.8,
          curvePivot = TRUE)
  
  # Adding the title separately because things were finnicky
  title("SEM: Environmental Effects on Bees and Flowers", line = 3)
}
```


Okay now let's get to the (comparatively) juicer and more statistically/
scientifically sound stuff, no road width measurements here
Plus other preparatory steps
```{r}
# Re-loading just in case... look idk I'm paranoid and there's no consequences
# to being inefficient in R ok
abiotics <- read_csv("~/Documents/repos/turbpe/spreadsheets/abiotics.csv")
flowers <- read_csv("~/Documents/repos/turbpe/spreadsheets/flowers.csv")
plant_IDs <- read_csv("~/Documents/repos/turbpe/spreadsheets/Plant_ID_list.csv")
bee_captures_8th <- read_csv("~/Documents/repos/turbpe/spreadsheets/bee_captures.csv") %>%
  filter(Replicate >= 1 & Replicate <= 8)

# Let's see what traffic-related columns actually exist
traffic_cols <- grep("traffic|Traffic", colnames(abiotics), value = TRUE, ignore.case = TRUE)
cat("\nTRAFFIC-RELATED COLUMNS:\n")
print(traffic_cols)

# Preparing plant taxonomy for flowers data
plant_IDs <- plant_IDs[!duplicated(plant_IDs$ID), ]
plant_IDs$Taxonomic_Name <- ifelse(
  !is.na(plant_IDs$Genus) & plant_IDs$Genus != "" & 
  !is.na(plant_IDs$Species) & plant_IDs$Species != "",
  paste(plant_IDs$Genus, plant_IDs$Species),
  as.character(plant_IDs$ID)
)

flowers_with_taxonomy <- merge(
  flowers,
  plant_IDs[, c("ID", "Taxonomic_Name")],
  by.x = "Species ID",  
  by.y = "ID",
  all.x = TRUE
)

flowers_with_taxonomy$Taxonomic_Name <- ifelse(
  is.na(flowers_with_taxonomy$Taxonomic_Name),
  as.character(flowers_with_taxonomy$`Species ID`),
  flowers_with_taxonomy$Taxonomic_Name
)
```

Clumping together the different data points for the purposes of the upcoming csv
file
```{r}
# Bees
bee_summary <- bee_captures_8th %>%
  group_by(Site, Replicate) %>%
  summarise(
    bee_abundance = n(),
    bee_richness = n_distinct(Genus, Species, na.rm = TRUE),
    .groups = 'drop'
  )

# Flowers
flower_summary <- flowers_with_taxonomy %>%
  filter(Replicate >= 1 & Replicate <= 8) %>%
  group_by(Site, Replicate) %>%
  summarise(
    total_flowers = sum(`# of Flowering Units`, na.rm = TRUE),
    flower_richness = n_distinct(Taxonomic_Name),
    .groups = 'drop'
  )

# 3. Abiotics
abiotic_summary <- abiotics %>%
  # Clean site names
  mutate(Site_Clean = case_when(
    grepl("Mean", Site) ~ gsub(" Mean", "", Site),
    grepl("M/S", Site) ~ gsub(" M/S", "", Site),
    TRUE ~ gsub("\\s.*", "", Site)
  )) %>%
  # Filter out "Total" and summary rows
  filter(!grepl("Total|Mean|M/S", Site, ignore.case = TRUE)) %>%
  # Convert traffic columns - USE BACKTICKS for problematic column names
  mutate(
    passenger_traffic = as.numeric(`Traffic_passenger`),
    bike_traffic = as.numeric(`Traffic_Bike`),
    truck_traffic = as.numeric(`Traffic_truck`)
  ) %>%
  # Group by clean site and date
  group_by(Site_Clean, Date) %>%
  summarise(
    mean_temp = mean(Temp, na.rm = TRUE),
    mean_humidity = mean(Humidity, na.rm = TRUE),
    mean_wind = mean(Wind, na.rm = TRUE),
    mean_volume = mean(Volume, na.rm = TRUE),
    total_traffic_passenger = sum(passenger_traffic, na.rm = TRUE),
    total_traffic_bike = sum(bike_traffic, na.rm = TRUE),
    total_traffic_truck = sum(truck_traffic, na.rm = TRUE),
    .groups = 'drop'
  ) %>%
  # Create replicate numbers based on date order
  group_by(Site_Clean) %>%
  arrange(Date) %>%
  mutate(Replicate = as.integer(factor(Date))) %>%
  ungroup() %>%
  # Filter to replicates 1-8
  filter(Replicate >= 1 & Replicate <= 8) %>%
  select(-Date) %>%
  rename(Site = Site_Clean) %>%
  # Create total_traffic here
  mutate(total_traffic = total_traffic_passenger + total_traffic_bike + total_traffic_truck)

# Diversity indices setup, familiar as previous. First with:
# For bees
bee_diversity_indices <- bee_captures_8th %>%
  group_by(Site, Replicate, Genus, Species) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(Site, Replicate) %>%
  summarise(
    bee_shannon = ifelse(n() > 1, diversity(count, index = "shannon"), 0),
    .groups = 'drop'
  )

# For flowers
flower_diversity_indices <- flowers_with_taxonomy %>%
  filter(Replicate >= 1 & Replicate <= 8) %>%
  group_by(Site, Replicate, Taxonomic_Name) %>%
  summarise(count = sum(`# of Flowering Units`, na.rm = TRUE), .groups = 'drop') %>%
  group_by(Site, Replicate) %>%
  summarise(
    flower_shannon = ifelse(n() > 1, diversity(count, index = "shannon"), 0),
    .groups = 'drop'
  )

# Site type again, I'm not gonna touch that right now
create_site_type <- function(site_code) {
  site_code <- as.character(site_code)
  if (grepl("P", site_code)) return("Positive")
  if (grepl("N", site_code)) return("Negative") 
  if (grepl("T", site_code)) return("Treatment")
  return(NA_character_)
}

# Actually forming the csv we want
sem_data_widthless <- bee_summary %>%
  full_join(flower_summary, by = c("Site", "Replicate")) %>%
  left_join(abiotic_summary, by = c("Site", "Replicate")) %>%
  left_join(bee_diversity_indices, by = c("Site", "Replicate")) %>%
  left_join(flower_diversity_indices, by = c("Site", "Replicate")) %>%
  mutate(
    Site_Type = sapply(Site, create_site_type),
    # Replace NAs with 0 for counts
    across(c(bee_abundance, bee_richness, total_flowers, flower_richness), 
           ~replace_na(., 0)),
    # Create mean traffic variables (instead of totals)
    mean_traffic_passenger = total_traffic_passenger / 3,  # Divide by 3 time periods
    mean_traffic_bike = total_traffic_bike / 3,
    mean_traffic_truck = total_traffic_truck / 3,
    mean_traffic = total_traffic / 3,
    bee_shannon = replace_na(bee_shannon, 0),
    flower_shannon = replace_na(flower_shannon, 0)
  ) %>%
  # Select only the variables we want
  select(
    Site, Replicate, 
    bee_abundance, bee_richness, bee_shannon,
    total_flowers, flower_richness, flower_shannon,
    mean_temp, mean_humidity, mean_wind, mean_volume,
    mean_traffic_passenger, mean_traffic_bike, mean_traffic_truck, mean_traffic,
    Site_Type
  )

# Check the dataset
cat("Width-less dataset created successfully!\n")
cat("Dimensions:", dim(sem_data_widthless), "\n")
cat("Variables:", paste(colnames(sem_data_widthless), collapse = ", "), "\n")

# Gotta chill again on creating extra files
# write_csv(sem_data_widthless, "sem_prepared_data_widthless.csv")
cat("Dataset saved as 'sem_prepared_data_widthless.csv' yippeee\n")
```

Time to make figures again whoooo
```{r}
sem_prepared_data_widthless <- read_csv("~/Documents/repos/turbpe/spreadsheets/sem_prepared_data_widthless.csv")
```

Words and numbers to describe our new csv whoo
```{r}
# Loading the width-less dataset
sem_prepared_data_widthless <- read_csv("~/Documents/repos/turbpe/spreadsheets/sem_prepared_data_widthless.csv")

# Checking data... ugh I should really get rid of all of them at this point, I
# have tested the code mutliple times...
cat("Width-less dataset structure:\n")
print(str(sem_prepared_data_widthless))
cat("\nSummary statistics:\n")
print(summary(sem_prepared_data_widthless))

# Cleaning data for SEM analysis
sem_data_clean_widthless <- sem_prepared_data_widthless %>%
  filter(!is.na(mean_temp) & 
         !is.na(mean_humidity) & 
         !is.na(mean_traffic)) %>%
  filter_all(all_vars(!is.infinite(.)))

cat("Clean dataset dimensions:", dim(sem_data_clean_widthless), "\n")

# Standardizing the data for SEM
sem_data_std_widthless <- sem_data_clean_widthless %>%
  mutate(across(where(is.numeric), scale))

# Self-explanatory title here, one of the biggest advantages of R
basic_widthless_model <- '
  # Direct effects on bees
  bee_abundance ~ total_flowers + mean_traffic + mean_temp + mean_humidity
  bee_richness ~ flower_richness + mean_traffic + mean_temp
  
  # Effects on flowers
  total_flowers ~ mean_traffic + mean_temp + mean_humidity
  flower_richness ~ mean_traffic + mean_temp + mean_humidity
  
  # Allow residuals to correlate
  bee_abundance ~~ bee_richness
  total_flowers ~~ flower_richness
  mean_traffic ~~ mean_temp + mean_humidity
  mean_temp ~~ mean_humidity
'

basic_fit <- sem(basic_widthless_model, data = sem_data_std_widthless)

cat("\nBASIC WIDTH-LESS SEM MODEL SUMMARY:\n")
print(summary(basic_fit, standardized = TRUE, fit.measures = TRUE, rsq = TRUE))

# Clear title again oooh, so easy so crisp
focused_model <- '
  # Core relationships only
  bee_abundance ~ total_flowers + mean_traffic
  bee_richness ~ flower_richness + mean_traffic
  total_flowers ~ mean_traffic
  flower_richness ~ mean_traffic
  
  # Correlations
  bee_abundance ~~ bee_richness
  total_flowers ~~ flower_richness
'

focused_fit <- sem(focused_model, data = sem_data_std_widthless)

cat("\nFOCUSED SEM MODEL SUMMARY:\n")
print(summary(focused_fit, standardized = TRUE, fit.measures = TRUE, rsq = TRUE))

# Yout get the idea now
traffic_components_model <- '
  # Test different traffic types
  bee_abundance ~ total_flowers + mean_traffic_passenger + mean_traffic_bike + mean_traffic_truck
  bee_richness ~ flower_richness + mean_traffic_passenger + mean_traffic_bike
  total_flowers ~ mean_traffic_passenger + mean_traffic_bike + mean_traffic_truck
  flower_richness ~ mean_traffic_passenger + mean_traffic_bike + mean_traffic_truck
  
  bee_abundance ~~ bee_richness
  total_flowers ~~ flower_richness
  mean_traffic_passenger ~~ mean_traffic_bike + mean_traffic_truck
  mean_traffic_bike ~~ mean_traffic_truck
'

traffic_fit <- sem(traffic_components_model, data = sem_data_std_widthless)

cat("\nTRAFFIC COMPONENTS SEM MODEL SUMMARY:\n")
print(summary(traffic_fit, standardized = TRUE, fit.measures = TRUE, rsq = TRUE))
```

This section is for creating a bunch of association plots now that we have a
more comfortable data set. But that does not by default mean we just let it rip
by default, so I have commented out the print commands here since they seem to
keep producing...
```{r}
p1 <- ggplot(sem_data_clean_widthless, aes(x = total_flowers, y = bee_abundance, color = Site_Type)) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(method = "lm", se = TRUE, alpha = 0.2) +
  labs(title = "Bee Abundance vs Flower Abundance",
       subtitle = "Colored by Site Type",
       x = "Total Flowers", y = "Bee Abundance") +
  theme_minimal() +
  scale_color_manual(values = c("Positive" = "#265380", "Negative" = "#E3DE2D", "Treatment" = "#76BD5C")) +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 11, face = "bold"),
    axis.title.y = element_text(size = 11, face = "bold")
  )
print(p1)

p1.no.outlier <- ggplot(subset(sem_data_clean_widthless, total_flowers<7000), aes(x = total_flowers, y = bee_abundance, color = Site_Type)) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(method = "lm", se = TRUE, alpha = 0.2) +
  labs(title = "Bee Abundance vs Flower Abundance",
       subtitle = "Colored by Site Type",
       x = "Total Flowers", y = "Bee Abundance") +
  theme_minimal() +
  scale_color_manual(values = c("Positive" = "#265380", "Negative" = "#E3DE2D", "Treatment" = "#76BD5C")) +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 11, face = "bold"),
    axis.title.y = element_text(size = 11, face = "bold")
  )
p1.no.outlier

p1.xlog <- ggplot(sem_data_clean_widthless, aes(x = total_flowers + 1, y = bee_abundance, color = Site_Type)) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(method = "lm", se = TRUE, alpha = 0.2) +
  labs(title = "Bee Abundance vs Flower Abundance",
       subtitle = "Colored by Site Type",
       x = "Total Flowers + 1", y = "Bee Abundance") +
  theme_minimal() +
  scale_x_log10() +
  scale_color_manual(values = c("Positive" = "#265380", "Negative" = "#E3DE2D", "Treatment" = "#76BD5C")) +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 11, face = "bold"),
    axis.title.y = element_text(size = 11, face = "bold")
  )
p1.xlog
```

```{r}
# Plot 2: Bee richness vs flower richness
p2 <- ggplot(sem_data_clean_widthless, aes(x = flower_richness, y = bee_richness, color = Site_Type)) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Bee Richness vs Flower Richness",
       x = "Flower Richness", y = "Bee Richness") +
  theme_minimal() +
  scale_color_manual(values = c("Positive" = "#265380", "Negative" = "#E3DE2D", "Treatment" = "#76BD5C")) +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 11, face = "bold"),
    axis.title.y = element_text(size = 11, face = "bold")
  )
print(p2)
```

```{r}
# Plot 3: Traffic effects
p3 <- ggplot(sem_data_clean_widthless, aes(x = mean_traffic, y = bee_abundance, color = Site_Type)) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(method = "lm", se = TRUE, alpha = 0.2) +
  labs(title = "Bee Abundance vs Traffic",
       x = "Mean Traffic", y = "Bee Abundance") +
  theme_minimal() +
  scale_color_manual(values = c("Positive" = "#265380", "Negative" = "#E3DE2D", "Treatment" = "#76BD5C")) +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 11, face = "bold"),
    axis.title.y = element_text(size = 11, face = "bold")
  )
print(p3)
```

```{r}
# Plot 4: Site type comparisons
p4 <- ggplot(sem_data_clean_widthless, aes(x = Site_Type, y = bee_abundance, fill = Site_Type)) +
  geom_boxplot(alpha = 0.7) +
  labs(title = "Bee Abundance by Site Type",
       x = "", y = "Bee Abundance") +
  theme_minimal() +
  scale_fill_manual(values = c("Positive" = "#265380", "Negative" = "#E3DE2D", "Treatment" = "#76DB5C")) +
  theme(
    legend.position = "none",
    plot.title = element_text(size = 16, face = "bold"),
    axis.title.y = element_text(size = 11, face = "bold")
  )
print(p4)
```

```{r}
# Plot 5: Traffic effects on flower richness
p5 <- ggplot(sem_data_clean_widthless, aes(x = mean_traffic, y = flower_richness, color = Site_Type)) +
  geom_point(alpha = 0.7, size = 2) +
  geom_smooth(method = "lm", se = TRUE, alpha = 0.2) +
  labs(title = "Flower Richness vs Traffic",
       x = "Mean Traffic", y = "Flower Richness") +
  theme_minimal() +
  scale_color_manual(values = c("Positive" = "#265380", "Negative" = "#E3DE2D", "Treatment" = "#76DB5C")) +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 14, face = "bold")
  )
print(p5)
```

Going to be honest I don't care for most of this text, but it does help me knit!
Or well, I ended up creating a variable which is later mandatory here
```{r}
cat("\n===~ KEY NUMERICAL FINDINGS ~===\n")

# Honestly I don't even remember how I got to creating this variable
fit_comparison <- tibble(
  Model = c("Basic", "Focused", "Traffic_Components"),
  chisq = c(fitMeasures(basic_fit, "chisq"), 
            fitMeasures(focused_fit, "chisq"),
            fitMeasures(traffic_fit, "chisq")),
  df = c(fitMeasures(basic_fit, "df"),
         fitMeasures(focused_fit, "df"),
         fitMeasures(traffic_fit, "df")),
  pvalue = c(fitMeasures(basic_fit, "pvalue"),
             fitMeasures(focused_fit, "pvalue"),
             fitMeasures(traffic_fit, "pvalue")),
  cfi = c(fitMeasures(basic_fit, "cfi"),
          fitMeasures(focused_fit, "cfi"),
          fitMeasures(traffic_fit, "cfi")),
  tli = c(fitMeasures(basic_fit, "tli"),
          fitMeasures(focused_fit, "tli"),
          fitMeasures(traffic_fit, "tli")),
  rmsea = c(fitMeasures(basic_fit, "rmsea"),
            fitMeasures(focused_fit, "rmsea"),
            fitMeasures(traffic_fit, "rmsea")),
  srmr = c(fitMeasures(basic_fit, "srmr"),
           fitMeasures(focused_fit, "srmr"),
           fitMeasures(traffic_fit, "srmr")),
  aic = c(fitMeasures(basic_fit, "aic"),
          fitMeasures(focused_fit, "aic"),
          fitMeasures(traffic_fit, "aic")),
  bic = c(fitMeasures(basic_fit, "bic"),
          fitMeasures(focused_fit, "bic"),
          fitMeasures(traffic_fit, "bic"))
)

cat("MODEL FIT COMPARISON:\n")
print(fit_comparison)

best_model <- focused_fit  # Based on simplicity and reasonable fit

significant_paths <- parameterEstimates(best_model, standardized = TRUE) %>%
  filter(op == "~") %>%
  select(From = rhs, To = lhs, Estimate = est, Std_Coefficient = std.all, P_Value = pvalue) %>%
  arrange(P_Value)

cat("\nSIGNIFICANT PATHS IN FOCUSED MODEL:\n")
print(significant_paths)

# R-squared values
rsq_values <- inspect(best_model, 'r2')
cat("\nEXPLAINED VARIANCE (R²):\n")
print(rsq_values)

# Words for key findings
cat("\n=== KEY INTERPRETATIONS ===\n")
cat("1. Strongest effects:\n")
cat("   - Flower richness → Bee richness (β = 0.317, p < 0.001)\n")
cat("   - Traffic → Bee abundance (β = -0.217, p = 0.010)\n") 
cat("   - Traffic → Flower richness (β = -0.184, p = 0.033)\n\n")

cat("2. Model performance:\n")
cat("   - Focused model has reasonable fit (CFI = 0.961)\n")
cat("   - Explains 13.4% of bee richness variance\n")
cat("   - Explains 6.1% of bee abundance variance\n\n")

cat("3. Impact of traffic:\n")
cat("   - Traffic negatively affects both bees and flowers\n")
cat("   - Passenger traffic shows strongest negative effects\n")
cat("   - Traffic reduces flower diversity more than flower abundance\n")
```


Finally the big structural equation model for this project! It looks...
underwhelming

Jeeeeeeeeezuss this package is miserable to work with. I'm grateful that it
exists to begin with (ty open source devs bless upppppp), but wowie this is the
third or fourth time I have been beefing with getting the functionalitites of
this dang package to actually work
```{r}
# Just kept it as barebones as possible no titles no info idc... will draw my
# own at some point I am not dealing with this package anympore
if(require(semPlot)) {
  dev.off()
  
  # Simple version but with taller device
  dev.new(width = 8, height = 10)  # Is this inches, "units", smth else idk
  par(mar = c(12, 5, 5, 5))       # 12 there makes bottom bigger?
  
  semPaths(focused_fit,
          what = "std",
          whatLabels = "std",
          style = "ram",
          layout = "spring",
          sizeMan = 15,
          sizeLat = 17,
          edge.label.cex = 1.2,
          curvePivot = TRUE,
          curve = 2.5,
          nCharNodes = 0,
          fade = FALSE)
  
  title("", cex.main = 1.2, line = 1)
  
  # Aaaaand I'm not touching that
  mtext("", side = 1, line = 8, cex = 0.8, col = "blue")
}
```
